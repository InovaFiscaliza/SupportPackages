function numericArray = getArrayFromByteStream(byteStream, errorCheckFlag)

    % Mimics the undocumented built-in function "getArrayFromByteStream" for 
    % byte streams of numeric arrays (real, imaginary, vector, matrix, double, 
    % uint8 etc)
    %
    % Reference:
    % - https://www.mathworks.com/help/pdf_doc/matlab/matfile_format.pdf
    % - https://www.mathworks.com/help/matlab/ref/computer.html
    %   (little-endian byte ordering for 64-bit Windows, Linux, and macOS
    %   platforms)

    arguments
        byteStream     uint8
        errorCheckFlag logical = false
    end

    % Input validation
    if ~isequal(byteStream(1:12), uint8([0,1,73,77,0,0,0,0,14,0,0,0])) && ... 
       ~isequal(byteStream(1:12), uint8([1,0,77,73,0,0,0,0,0,0,0,14]))
        error('The input must be a uint8 byte stream generated by MATLAB.')
    end

    switch char(byteStream(3:4))
        case 'IM'
            EndianIndicator = 'LittleEndian';
        case 'MI'
            EndianIndicator = 'BigEndian';
    end

    try
        numericClassName    = DataTypeMapping(byteStream(25));
        dataSubTypeID       = byteStream(26);
        xSize               = ParseBlock(byteStream, 41, 44, 'uint32', EndianIndicator);
        ySize               = ParseBlock(byteStream, 45, 48, 'uint32', EndianIndicator);
        zSize               = ParseBlock(byteStream, 49, 52, 'uint32', EndianIndicator);
        numericArray        = zeros(xSize, ySize, zSize, numericClassName);

        % 3D arrays adds 8 more bytes to the header: uint32([1,0])
        byteOffset = 56;
        if zSize ~= 1
            byteOffset = byteOffset+8;
        end

        if numel(typecast(numericArray(:), 'uint8')) <= 4
            byteStreamBlockHeaderLength = 4;            
            numericUint8ArrayLength = typecast(byteStream(byteOffset+3:byteOffset+4), 'uint16');
        else
            byteStreamBlockHeaderLength = 8;
            numericUint8ArrayLength = typecast(byteStream(byteOffset+5:byteOffset+8), 'uint32');
        end
        [numericArray(:), byteOffset] = ReadArrayData(numericUint8ArrayLength, numericClassName, byteStream, byteStreamBlockHeaderLength, byteOffset);

        switch dataSubTypeID
            case 2
                numericArray     = logical(numericArray);
            case 8
                compNumericArray = double(ReadArrayData(numericUint8ArrayLength, numericClassName, byteStream, byteStreamBlockHeaderLength, byteOffset))' * 1i;
                numericArray(:)  = eval(sprintf('%s(double(numericArray(:)) + compNumericArray)', numericClassName));
        end

    catch ME
        error('Unable to read data stream because MATLAB is out of memory or the stream contains a bad version or endian-key')
    end

    if errorCheckFlag
        numericArrayMATLAB = getArrayFromByteStream(byteStream);              % MATLAB undocumented built-in function

        if ~isequal(numericArray, numericArrayMATLAB)
            numericArrayMATLABString = "[" + strjoin(string(numericArrayMATLAB), ', ') + "]";
            numericArrayString       = "[" + strjoin(string(numericArray),       ', ') + "]";

            error('Unexpected Numeric Array\nBuilt-in: %s\nCustom:   %s', numericArrayMATLABString, numericArrayString)
        end
    end
end


%-------------------------------------------------------------------------%
function className = DataTypeMapping(classID)
    switch classID
        case  6,   className = 'double';
        case  7,   className = 'single';
        case  8,   className = 'int8';
        case  9,   className = 'uint8';
        case 10,   className = 'int16';
        case 11,   className = 'uint16';
        case 12,   className = 'int32';
        case 13,   className = 'uint32';
        case 14,   className = 'int64';
        case 15,   className = 'uint64';
        otherwise; error('Unexpected data type "%s"', classID)
    end
end


%-------------------------------------------------------------------------%
function parsedBlock = ParseBlock(byteStream, idxBegin, idxEnd, className, EndianIndicator)
    byteStreamBlock = byteStream(idxBegin:idxEnd);
    if EndianIndicator == "BigEndian"
        byteStreamBlock = swapbytes(byteStreamBlock);
    end

    parsedBlock = typecast(byteStreamBlock, className);
end


%-------------------------------------------------------------------------%
function [numericArray, byteOffset] = ReadArrayData(numericUint8ArrayLength, numericClassName, byteStream, byteStreamBlockHeaderLength, byteOffset)
    byteOffset   = byteOffset+byteStreamBlockHeaderLength;
    numericArray = typecast(byteStream(byteOffset+1:byteOffset+numericUint8ArrayLength), numericClassName);

    byteOffset   = byteOffset+numericUint8ArrayLength;
    if mod(byteOffset, 8)
        byteOffset = byteOffset + (8 - mod(byteOffset, 8));
    end
end